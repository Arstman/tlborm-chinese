<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Debugging</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='mbe-README.html'><b>2.</b> Macros, A Methodical Introduction</a>
<ul class='section'>
<li><a  href='mbe-syn-README.html'><b>2.1.</b> Syntax Extensions</a>
<ul class='section'>
<li><a  href='mbe-syn-source-analysis.html'><b>2.1.1.</b> Source Analysis</a>
</li>
<li><a  href='mbe-syn-macros-in-the-ast.html'><b>2.1.2.</b> Macros in the AST</a>
</li>
<li><a  href='mbe-syn-expansion.html'><b>2.1.3.</b> Expansion</a>
</li>
</ul>
</li>
<li><a  href='mbe-macro-rules.html'><b>2.2.</b> macro_rules!</a>
</li>
<li><a  href='mbe-min-README.html'><b>2.3.</b> Minutiae</a>
<ul class='section'>
<li><a  href='mbe-min-captures-and-expansion-redux.html'><b>2.3.1.</b> Captures and Expansion Redux</a>
</li>
<li><a  href='mbe-min-hygiene.html'><b>2.3.2.</b> Hygiene</a>
</li>
<li><a  href='mbe-min-non-identifier-identifiers.html'><b>2.3.3.</b> Non-Identifier Identifiers</a>
</li>
<li><a class='active' href='mbe-min-debugging.html'><b>2.3.4.</b> Debugging</a>
</li>
<li><a  href='mbe-min-scoping.html'><b>2.3.5.</b> Scoping</a>
</li>
<li><a  href='mbe-min-import-export.html'><b>2.3.6.</b> Import/Export</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='pim-README.html'><b>3.</b> Macros, A Practical Introduction</a>
</li>
<li><a  href='pat-README.html'><b>4.</b> Patterns</a>
<ul class='section'>
<li><a  href='pat-callbacks.html'><b>4.1.</b> Callbacks</a>
</li>
<li><a  href='pat-incremental-tt-munchers.html'><b>4.2.</b> Incremental TT Munchers</a>
</li>
<li><a  href='pat-internal-rules.html'><b>4.3.</b> Internal Rules</a>
</li>
<li><a  href='pat-push-down-accumulation.html'><b>4.4.</b> Push-Down Accumulation</a>
</li>
<li><a  href='pat-repetition-replacement.html'><b>4.5.</b> Repetition Replacement</a>
</li>
<li><a  href='pat-trailing-separators.html'><b>4.6.</b> Trailing Separators</a>
</li>
<li><a  href='pat-tt-bundling.html'><b>4.7.</b> TT Bundling</a>
</li>
<li><a  href='pat-visibility.html'><b>4.8.</b> Visibility</a>
</li>
<li><a  href='pat-provisional.html'><b>4.9.</b> Provisional</a>
</li>
</ul>
</li>
<li><a  href='blk-README.html'><b>5.</b> Building Blocks</a>
<ul class='section'>
<li><a  href='blk-ast-coercion.html'><b>5.1.</b> AST Coercion</a>
</li>
<li><a  href='blk-counting.html'><b>5.2.</b> Counting</a>
</li>
<li><a  href='blk-enum-parsing.html'><b>5.3.</b> Enum Parsing</a>
</li>
</ul>
</li>
<li><a  href='aeg-README.html'><b>6.</b> Annotated Examples</a>
<ul class='section'>
<li><a  href='aeg-ook.html'><b>6.1.</b> Ook!</a>
</li>
</ul>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Debugging</h1>
    <p><code>rustc</code> provides a number of tools to debug macros.  One of the most useful is <code>trace_macros!</code>, which is a directive to the compiler instructing it to dump every macro invocation prior to expansion.  For example, given the following:</p>
<span class='rusttest'>// Note: make sure to use a nightly channel compiler.
#![feature(trace_macros)]

macro_rules! each_tt {
    () =&gt; {};
    ($_tt:tt $($rest:tt)*) =&gt; {each_tt!($($rest)*);};
}

each_tt!(foo bar baz quux);
trace_macros!(true);
each_tt!(spim wak plee whum);
trace_macros!(false);
each_tt!(trom qlip winp xod);

fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>trace_macros</span>)]</span>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>each_tt</span> {
    () <span class='op'>=&gt;</span> {};
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_tt</span>:<span class='ident'>tt</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {<span class='macro'>each_tt</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>)<span class='op'>*</span>);};
}

<span class='macro'>each_tt</span><span class='macro'>!</span>(<span class='ident'>foo</span> <span class='ident'>bar</span> <span class='ident'>baz</span> <span class='ident'>quux</span>);
<span class='macro'>trace_macros</span><span class='macro'>!</span>(<span class='boolval'>true</span>);
<span class='macro'>each_tt</span><span class='macro'>!</span>(<span class='ident'>spim</span> <span class='ident'>wak</span> <span class='ident'>plee</span> <span class='ident'>whum</span>);
<span class='macro'>trace_macros</span><span class='macro'>!</span>(<span class='boolval'>false</span>);
<span class='macro'>each_tt</span><span class='macro'>!</span>(<span class='ident'>trom</span> <span class='ident'>qlip</span> <span class='ident'>winp</span> <span class='ident'>xod</span>);</pre>

<p>The output is:</p>

<pre><code class="language-text">each_tt! { spim wak plee whum }
each_tt! { wak plee whum }
each_tt! { plee whum }
each_tt! { whum }
each_tt! {  }
</code></pre>

<p>This is <em>particularly</em> invaluable when debugging deeply recursive macros.  You can also enable this from the command-line by adding <code>-Z trace-macros</code> to the compiler command line.</p>

<p>Secondly, there is <code>log_syntax!</code> which causes the compiler to output all tokens passed to it.  For example, this makes the compiler sing a song:</p>
<span class='rusttest'>// Note: make sure to use a nightly channel compiler.
#![feature(log_syntax)]

macro_rules! sing {
    () =&gt; {};
    ($tt:tt $($rest:tt)*) =&gt; {log_syntax!($tt); sing!($($rest)*);};
}

sing! {
    ^ &lt; @ &lt; . @ *
    &#39;\x08&#39; &#39;{&#39; &#39;&quot;&#39; _ # &#39; &#39;
    - @ &#39;$&#39; &amp;&amp; / _ %
    ! ( &#39;\t&#39; @ | = &gt;
    ; &#39;\x08&#39; &#39;\&#39;&#39; + &#39;$&#39; ? &#39;\x7f&#39;
    , # &#39;&quot;&#39; ~ | ) &#39;\x07&#39;
}

fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>log_syntax</span>)]</span>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>sing</span> {
    () <span class='op'>=&gt;</span> {};
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tt</span>:<span class='ident'>tt</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {<span class='macro'>log_syntax</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tt</span>); <span class='macro'>sing</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>)<span class='op'>*</span>);};
}

<span class='macro'>sing</span><span class='macro'>!</span> {
    <span class='op'>^</span> <span class='op'>&lt;</span> <span class='kw-2'>@</span> <span class='op'>&lt;</span> . <span class='kw-2'>@</span> <span class='op'>*</span>
    <span class='string'>&#39;\x08&#39;</span> <span class='string'>&#39;{&#39;</span> <span class='string'>&#39;&quot;&#39;</span> _ <span class='attribute'># <span class='string'>&#39; &#39;</span>
    <span class='op'>-</span> <span class='kw-2'>@</span> <span class='string'>&#39;$&#39;</span> <span class='op'>&amp;&amp;</span> <span class='op'>/</span> _ <span class='op'>%</span>
    <span class='op'>!</span> ( <span class='string'>&#39;\t&#39;</span> <span class='kw-2'>@</span> <span class='op'>|</span> <span class='op'>=</span> <span class='op'>&gt;</span>
    ; <span class='string'>&#39;\x08&#39;</span> <span class='string'>&#39;\&#39;&#39;</span> <span class='op'>+</span> <span class='string'>&#39;$&#39;</span> ? <span class='string'>&#39;\x7f&#39;</span>
    , <span class='attribute'># <span class='string'>&#39;&quot;&#39;</span> <span class='kw-2'>~</span> <span class='op'>|</span> ) <span class='string'>&#39;\x07&#39;</span>
}</pre>

<p>This can be used to do slightly more targeted debugging than <code>trace_macros!</code>.</p>

<p>Sometimes, it is what the macro <em>expands to</em> that proves problematic.  For this, the <code>--pretty</code> argument to the compiler can be used.  Given the following code:</p>
<span class='rusttest'>// Shorthand for initialising a `String`.
macro_rules! S {
    ($e:expr) =&gt; {String::from($e)};
}

fn main() {
    let world = S!(&quot;World&quot;);
    println!(&quot;Hello, {}!&quot;, world);
}
</span><pre class='rust rust-example-rendered'>
<span class='comment'>// Shorthand for initialising a `String`.</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>S</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='ident'>String</span>::<span class='ident'>from</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>)};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>world</span> <span class='op'>=</span> <span class='macro'>S</span><span class='macro'>!</span>(<span class='string'>&quot;World&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, {}!&quot;</span>, <span class='ident'>world</span>);
}</pre>

<p>compiled with the following command:</p>

<pre><code class="language-shell">rustc -Z unstable-options --pretty expanded hello.rs
</code></pre>

<p>produces the following output (modified for formatting):</p>
<span class='rusttest'>#![feature(no_std, prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
// Shorthand for initialising a `String`.
fn main() {
    let world = String::from(&quot;World&quot;);
    ::std::io::_print(::std::fmt::Arguments::new_v1(
        {
            static __STATIC_FMTSTR: &amp;&#39;static [&amp;&#39;static str]
                = &amp;[&quot;Hello, &quot;, &quot;!\n&quot;];
            __STATIC_FMTSTR
        },
        &amp;match (&amp;world,) {
             (__arg0,) =&gt; [
                ::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)
            ],
        }
    ));
}
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>no_std</span>, <span class='ident'>prelude_import</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>
<span class='attribute'>#[<span class='ident'>prelude_import</span>]</span>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>prelude</span>::<span class='ident'>v1</span>::<span class='op'>*</span>;
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>std</span> <span class='kw'>as</span> <span class='ident'>std</span>;
<span class='comment'>// Shorthand for initialising a `String`.</span>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>world</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;World&quot;</span>);
    ::<span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>_print</span>(::<span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Arguments</span>::<span class='ident'>new_v1</span>(
        {
            <span class='kw'>static</span> <span class='ident'>__STATIC_FMTSTR</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> [<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>]
                <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&quot;Hello, &quot;</span>, <span class='string'>&quot;!\n&quot;</span>];
            <span class='ident'>__STATIC_FMTSTR</span>
        },
        <span class='kw-2'>&amp;</span><span class='kw'>match</span> (<span class='kw-2'>&amp;</span><span class='ident'>world</span>,) {
             (<span class='ident'>__arg0</span>,) <span class='op'>=&gt;</span> [
                ::<span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>ArgumentV1</span>::<span class='ident'>new</span>(<span class='ident'>__arg0</span>, ::<span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Display</span>::<span class='ident'>fmt</span>)
            ],
        }
    ));
}</pre>

<p>Other options to <code>--pretty</code> can be listed using <code>rustc -Z unstable-options --help -v</code>; a full list is not provided since, as implied by the name, any such list would be subject to change at any time.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
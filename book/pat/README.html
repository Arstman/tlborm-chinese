<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Patterns</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../mbe.html'><b>2.</b> Macros</a>
</li>
<li><a class='active' href='../pat/README.html'><b>3.</b> Patterns</a>
</li>
<li><a  href='../blk/README.html'><b>4.</b> Building Blocks</a>
</li>
<li><a  href='../aeg/README.html'><b>5.</b> Annotated Examples</a>
<ul class='section'>
<li><a  href='../aeg/ook.html'><b>5.1.</b> Ook!</a>
</li>
</ul>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Patterns</h1>
    <p>Parsing and expansion patterns.</p>

<h2 id="incremental-tt-munchers" class='section-header'><a
                           href="#incremental-tt-munchers">Incremental TT munchers</a></h2><span class='rusttest'>fn main() {
    macro_rules! mixed_rules {
        () =&gt; {};
        (trace $name:ident; $($tail:tt)*) =&gt; {
            {
                println!(concat!(stringify!($name), &quot; = {:?}&quot;), $name);
                mixed_rules!($($tail)*);
            }
        };
        (trace $name:ident = $init:expr; $($tail:tt)*) =&gt; {
            {
                let $name = $init;
                println!(concat!(stringify!($name), &quot; = {:?}&quot;), $name);
                mixed_rules!($($tail)*);
            }
        };
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>mixed_rules</span> {
    () <span class='op'>=&gt;</span> {};
    (<span class='ident'>trace</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>:<span class='ident'>ident</span>; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='macro'>concat</span><span class='macro'>!</span>(<span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>), <span class='string'>&quot; = {:?}&quot;</span>), <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>);
            <span class='macro'>mixed_rules</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>)<span class='op'>*</span>);
        }
    };
    (<span class='ident'>trace</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>:<span class='ident'>ident</span> <span class='op'>=</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>init</span>:<span class='ident'>expr</span>; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span> <span class='op'>=</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>init</span>;
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='macro'>concat</span><span class='macro'>!</span>(<span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>), <span class='string'>&quot; = {:?}&quot;</span>), <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>);
            <span class='macro'>mixed_rules</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>)<span class='op'>*</span>);
        }
    };
}</pre>

<p>This pattern is perhaps the <em>most powerful</em> macro parsing technique available, allowing one to parse grammars of significant complexity.</p>

<p>A &quot;TT muncher&quot; is a recursive macro that works by incrementally processing its input one step at a time.  At each step, it matches and removes (munches) some sequence of tokens from the start of its input, generates some intermediate output, then recurses on the input tail.</p>

<p>The reason for &quot;TT&quot; in the name specifically is that the unprocessed part of the input is <em>always</em> captured as <code>$($tail:tt)*</code>.  This is done as a <code>tt</code> repetition is the only way to <em>losslessly</em> capture part of a macro&#39;s input.</p>

<p>The only hard restrictions on TT munchers are those imposed on the macro system as a whole:</p>

<ul>
<li>You can only match against literals and grammar constructs which can be captured by <code>macro_rules!</code>.</li>
<li>You cannot match unbalanced groups.</li>
</ul>

<p>It is important, however, to keep the macro recursion limit in mind.  <code>macro_rules!</code> does not have <em>any</em> form of tail recursion elimination or optimisation.  It is recommended that, when writing a TT muncher, you make reasonable efforts to keep recursion as limited as possible.  This can be done by adding additional rules to account for variation in the input (as opposed to recursion into an intermediate layer), or by making compromises on the input syntax to make using standard repetitions more tractable.</p>

<h2 id="internal-rules" class='section-header'><a
                           href="#internal-rules">Internal rules</a></h2><span class='rusttest'>fn main() {
    #[macro_export]
    macro_rules! foo {
        (@as_expr $e:expr) =&gt; {$e};
    
        // ...
    
        ($($tts:tt)*) =&gt; {
            foo!(@as_expr $($tts)*)
        };
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='kw-2'>@</span><span class='ident'>as_expr</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>};

    <span class='comment'>// ...</span>

    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tts</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>foo</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>as_expr</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tts</span>)<span class='op'>*</span>)
    };
}</pre>

<p>Because macros do not interact with regular item privacy or lookup, any public macro <em>must</em> bring with it all other macros that it depends on.  This can lead to pollution of the global macro namespace, or even conflicts with macros from other crates.  It may also cause confusion to users who attempt to <em>selectively</em> import macros: they must transitively import <em>all</em> macros, including ones that may not be publicly documented.</p>

<p>A good solution is to conceal what would otherwise be other public macros <em>inside</em> the macro being exported.  The above example shows how the common <code>as_expr!</code> macro could be moved <em>into</em> the publicly exported macro that is using it.</p>

<p>The reason for using <code>@</code> is that, as of Rust 1.2, the <code>@</code> token is <em>not</em> used <em>anywhere</em> in the Rust grammar; as such, it cannot possibly conflict with anything.  Other symbols or unique prefixes may be used as desired, but use of <code>@</code> has started to become widespread, so using it may aid readers in understanding your code.</p>

<blockquote>
<p><strong>Note</strong>: the <code>@</code> token is a hold-over from when Rust used sigils to denote the various built-in pointer types.  <code>@</code> in particular was for garbage-collected pointers.</p>
</blockquote>

<p>Additionally, internal rules will often come <em>before</em> any &quot;bare&quot; rules, to avoid issues with <code>macro_rules!</code> incorrectly attempting to parse an internal invocation as something it cannot possibly be, such as an expression.</p>

<p>If exporting at least one internal macro is unavoidable (<em>e.g.</em> you have many macros that depend on a common set of utility rules), you can use this pattern to combine <em>all</em> internal macros into a single uber-macro.</p>
<span class='rusttest'>fn main() {
    macro_rules! crate_name_util {
        (@as_expr $e:expr) =&gt; {$e};
        (@as_item $i:item) =&gt; {$i};
        (@count_tts) =&gt; {0usize};
        // ...
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>crate_name_util</span> {
    (<span class='kw-2'>@</span><span class='ident'>as_expr</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>};
    (<span class='kw-2'>@</span><span class='ident'>as_item</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>i</span>:<span class='ident'>item</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>i</span>};
    (<span class='kw-2'>@</span><span class='ident'>count_tts</span>) <span class='op'>=&gt;</span> {<span class='number'>0usize</span>};
    <span class='comment'>// ...</span>
}</pre>

<h2 id="push-down-accumulation" class='section-header'><a
                           href="#push-down-accumulation">Push-down Accumulation</a></h2><span class='rusttest'>fn main() {
    macro_rules! init_array {
        (@accum (0, $_e:expr) -&gt; ($($body:tt)*))
            =&gt; {init_array!(@as_expr [$($body)*])};
        (@accum (1, $e:expr) -&gt; ($($body:tt)*))
            =&gt; {init_array!(@accum (0, $e) -&gt; ($($body)* $e,))};
        (@accum (2, $e:expr) -&gt; ($($body:tt)*))
            =&gt; {init_array!(@accum (1, $e) -&gt; ($($body)* $e,))};
        (@accum (3, $e:expr) -&gt; ($($body:tt)*))
            =&gt; {init_array!(@accum (2, $e) -&gt; ($($body)* $e,))};
        (@as_expr $e:expr) =&gt; {$e};
        [$e:expr; $n:tt] =&gt; {
            {
                let e = $e;
                init_array!(@accum ($n, e.clone()) -&gt; ())
            }
        };
    }
    
    let strings: [String; 3] = init_array![String::from(&quot;hi!&quot;); 3];
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>init_array</span> {
    (<span class='kw-2'>@</span><span class='ident'>accum</span> (<span class='number'>0</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>:<span class='ident'>tt</span>)<span class='op'>*</span>))
        <span class='op'>=&gt;</span> {<span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>as_expr</span> [$(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>)<span class='op'>*</span>])};
    (<span class='kw-2'>@</span><span class='ident'>accum</span> (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>:<span class='ident'>tt</span>)<span class='op'>*</span>))
        <span class='op'>=&gt;</span> {<span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> (<span class='number'>0</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>)<span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>,))};
    (<span class='kw-2'>@</span><span class='ident'>accum</span> (<span class='number'>2</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>:<span class='ident'>tt</span>)<span class='op'>*</span>))
        <span class='op'>=&gt;</span> {<span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>)<span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>,))};
    (<span class='kw-2'>@</span><span class='ident'>accum</span> (<span class='number'>3</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>:<span class='ident'>tt</span>)<span class='op'>*</span>))
        <span class='op'>=&gt;</span> {<span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> (<span class='number'>2</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>)<span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>,))};
    (<span class='kw-2'>@</span><span class='ident'>as_expr</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>};
    [<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>n</span>:<span class='ident'>tt</span>] <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='ident'>e</span> <span class='op'>=</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>;
            <span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>n</span>, <span class='ident'>e</span>.<span class='ident'>clone</span>()) <span class='op'>-&gt;</span> ())
        }
    };
}

<span class='kw'>let</span> <span class='ident'>strings</span>: [<span class='ident'>String</span>; <span class='number'>3</span>] <span class='op'>=</span> <span class='macro'>init_array</span><span class='macro'>!</span>[<span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hi!&quot;</span>); <span class='number'>3</span>];</pre>

<p>All macros in Rust <strong>must</strong> result in a complete, supported syntax element (such as an expression, item, <em>etc.</em>).  This means that it is impossible to have a macro expand to a partial construct.</p>

<p>One might hope that the above example could be more directly expressed like so:</p>
<span class='rusttest'>fn main() {
    macro_rules! init_array {
        (@accum 0, $_e:expr) =&gt; {/* empty */};
        (@accum 1, $e:expr) =&gt; {$e};
        (@accum 2, $e:expr) =&gt; {$e, init_array!(@accum 1, $e)};
        (@accum 3, $e:expr) =&gt; {$e, init_array!(@accum 2, $e)};
        [$e:expr; $n:tt] =&gt; {
            {
                let e = $e;
                [init_array!(@accum $n, e)]
            }
        };
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>init_array</span> {
    (<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>0</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='comment'>/* empty */</span>};
    (<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>};
    (<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>2</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>, <span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>)};
    (<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>3</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>, <span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>2</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>)};
    [<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>n</span>:<span class='ident'>tt</span>] <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='ident'>e</span> <span class='op'>=</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>;
            [<span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>n</span>, <span class='ident'>e</span>)]
        }
    };
}</pre>

<p>The expectation is that the expansion of the array literal would proceed as follows:</p>
<span class='rusttest'>fn main() {
                [init_array!(@accum 3, e)]
                [e, init_array!(@accum 2, e)]
                [e, e, init_array!(@accum 1, e)]
                [e, e, e]
    
}</span><pre class='rust rust-example-rendered'>
            [<span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>3</span>, <span class='ident'>e</span>)]
            [<span class='ident'>e</span>, <span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>2</span>, <span class='ident'>e</span>)]
            [<span class='ident'>e</span>, <span class='ident'>e</span>, <span class='macro'>init_array</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>accum</span> <span class='number'>1</span>, <span class='ident'>e</span>)]
            [<span class='ident'>e</span>, <span class='ident'>e</span>, <span class='ident'>e</span>]</pre>

<p>However, this would require each intermediate step to expand to an incomplete expression.  Even though the intermediate results will never be used <em>outside</em> of a macro context, it is still forbidden.</p>

<p>Push-down, however, allows us to incrementally build up a sequence of tokens without needing to actually have a complete construct at any point prior to completion.  In the example given at the top, the sequence of macro invocations proceeds as follows:</p>
<span class='rusttest'>fn main() {
    init_array! { String:: from ( &quot;hi!&quot; ) ; 3 }
    init_array! { @ accum ( 3 , e . clone (  ) ) -&gt; (  ) }
    init_array! { @ accum ( 2 , e.clone() ) -&gt; ( e.clone() , ) }
    init_array! { @ accum ( 1 , e.clone() ) -&gt; ( e.clone() , e.clone() , ) }
    init_array! { @ accum ( 0 , e.clone() ) -&gt; ( e.clone() , e.clone() , e.clone() , ) }
    init_array! { @ as_expr [ e.clone() , e.clone() , e.clone() , ] }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>init_array</span><span class='macro'>!</span> { <span class='ident'>String</span>:: <span class='ident'>from</span> ( <span class='string'>&quot;hi!&quot;</span> ) ; <span class='number'>3</span> }
<span class='macro'>init_array</span><span class='macro'>!</span> { <span class='kw-2'>@</span> <span class='ident'>accum</span> ( <span class='number'>3</span> , <span class='ident'>e</span> . <span class='ident'>clone</span> (  ) ) <span class='op'>-&gt;</span> (  ) }
<span class='macro'>init_array</span><span class='macro'>!</span> { <span class='kw-2'>@</span> <span class='ident'>accum</span> ( <span class='number'>2</span> , <span class='ident'>e</span>.<span class='ident'>clone</span>() ) <span class='op'>-&gt;</span> ( <span class='ident'>e</span>.<span class='ident'>clone</span>() , ) }
<span class='macro'>init_array</span><span class='macro'>!</span> { <span class='kw-2'>@</span> <span class='ident'>accum</span> ( <span class='number'>1</span> , <span class='ident'>e</span>.<span class='ident'>clone</span>() ) <span class='op'>-&gt;</span> ( <span class='ident'>e</span>.<span class='ident'>clone</span>() , <span class='ident'>e</span>.<span class='ident'>clone</span>() , ) }
<span class='macro'>init_array</span><span class='macro'>!</span> { <span class='kw-2'>@</span> <span class='ident'>accum</span> ( <span class='number'>0</span> , <span class='ident'>e</span>.<span class='ident'>clone</span>() ) <span class='op'>-&gt;</span> ( <span class='ident'>e</span>.<span class='ident'>clone</span>() , <span class='ident'>e</span>.<span class='ident'>clone</span>() , <span class='ident'>e</span>.<span class='ident'>clone</span>() , ) }
<span class='macro'>init_array</span><span class='macro'>!</span> { <span class='kw-2'>@</span> <span class='ident'>as_expr</span> [ <span class='ident'>e</span>.<span class='ident'>clone</span>() , <span class='ident'>e</span>.<span class='ident'>clone</span>() , <span class='ident'>e</span>.<span class='ident'>clone</span>() , ] }</pre>

<p>As you can see, each layer adds to the accumulated output until the terminating rule finally emits it as a complete construct.</p>

<p>The only critical part of the above formulation is the use of <code>$($body:tt)*</code> to preserve the output without triggering parsing.  The use of <code>($input) -&gt; ($output)</code> is simply a convention adopted to help clarify the behaviour of such macros.</p>

<p>Push-down accumulation is frequently used as part of <a href="#incremental-tt-munchers">incremental TT munchers</a>, as it allows arbitrarily complex intermediate results to be constructed.</p>

<h2 id="repetition-replacement" class='section-header'><a
                           href="#repetition-replacement">Repetition replacement</a></h2><span class='rusttest'>fn main() {
    macro_rules! replace_expr {
        ($_t:tt $sub:expr) =&gt; {$sub};
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>replace_expr</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_t</span>:<span class='ident'>tt</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sub</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sub</span>};
}</pre>

<p>This pattern is where a matched repetition sequence is simply discarded, with the variable being used to instead drive some repeated pattern that is related to the input only in terms of length.</p>

<p>For example, consider constructing a default instance of a tuple with more than 12 elements (the limit as of Rust 1.2).</p>
<span class='rusttest'>fn main() {
    macro_rules! tuple_default {
        ($($tup_tys:ty),*) =&gt; {
            (
                $(
                    replace_expr!(
                        ($tup_tys)
                        Default::default()
                    ),
                )*
            )
        };
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>tuple_default</span> {
    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tup_tys</span>:<span class='ident'>ty</span>),<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        (
            $(
                <span class='macro'>replace_expr</span><span class='macro'>!</span>(
                    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tup_tys</span>)
                    <span class='ident'>Default</span>::<span class='ident'>default</span>()
                ),
            )<span class='op'>*</span>
        )
    };
}</pre>

<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: we <em>could</em> have simply used <code>$tup_tys::default()</code>.</p>
</blockquote>

<p>Here, we are not actually <em>using</em> the matched types.  Instead, we throw them away and instead replace them with a single, repeated expression.  To put it another way, we don&#39;t care <em>what</em> the types are, only <em>how many</em> there are.</p>

<h2 id="trailing-separators" class='section-header'><a
                           href="#trailing-separators">Trailing separators</a></h2><span class='rusttest'>fn main() {
    macro_rules! match_exprs {
        ($($exprs:expr),* $(,)*) =&gt; {...};
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>match_exprs</span> {
    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>exprs</span>:<span class='ident'>expr</span>),<span class='op'>*</span> $(,)<span class='op'>*</span>) <span class='op'>=&gt;</span> {...};
}</pre>

<p>There are various places in the Rust grammar where trailing commas are permitted.  The two common ways of matching (for example) a list of expressions (<code>$($exprs:expr),*</code> and <code>$($exprs:expr,)*</code>) can deal with <em>either</em> no trailing comma <em>or</em> a trailing comma, but <em>not both</em>.</p>

<p>Placing a <code>$(,)*</code> repetition <em>after</em> the main list, however, will capture any number (including zero or one) of trailing commas, or any other separator you may be using.</p>

<p>Note that this cannot be used in all contexts.  If the compiler rejects this, you will likely need to use multiple arms and/or incremental matching.</p>

<h2 id="tt-bundling" class='section-header'><a
                           href="#tt-bundling">TT Bundling</a></h2><span class='rusttest'>macro_rules! call_a_or_b_on_tail {
    ((a: $a:expr, b: $b:expr), call a: $($tail:tt)*) =&gt; {
        $a(stringify!($($tail)*))
    };

    ((a: $a:expr, b: $b:expr), call b: $($tail:tt)*) =&gt; {
        $b(stringify!($($tail)*))
    };

    ($ab:tt, $_skip:tt $($tail:tt)*) =&gt; {
        call_a_or_b_on_tail!($ab, $($tail)*)
    };
}

fn compute_len(s: &amp;str) -&gt; Option&lt;usize&gt; {
    Some(s.len())
}

fn show_tail(s: &amp;str) -&gt; Option&lt;usize&gt; {
    println!(&quot;tail: {:?}&quot;, s);
    None
}

fn main() {
    assert_eq!(
        call_a_or_b_on_tail!(
            (a: compute_len, b: show_tail),
            the recursive part that skips over all these
            tokens doesn&#39;t much care whether we will call a
            or call b: only the terminal rules care.
        ),
        None
    );
    assert_eq!(
        call_a_or_b_on_tail!(
            (a: compute_len, b: show_tail),
            and now, to justify the existence of two paths
            we will also call a: its input should somehow
            be self-referential, so let&#39;s make it return
            some ninety one!
        ),
        Some(91)
    );
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>call_a_or_b_on_tail</span> {
    ((<span class='ident'>a</span>: <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>a</span>:<span class='ident'>expr</span>, <span class='ident'>b</span>: <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>b</span>:<span class='ident'>expr</span>), <span class='ident'>call</span> <span class='ident'>a</span>: $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>a</span>(<span class='macro'>stringify</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>)<span class='op'>*</span>))
    };

    ((<span class='ident'>a</span>: <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>a</span>:<span class='ident'>expr</span>, <span class='ident'>b</span>: <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>b</span>:<span class='ident'>expr</span>), <span class='ident'>call</span> <span class='ident'>b</span>: $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>b</span>(<span class='macro'>stringify</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>)<span class='op'>*</span>))
    };

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ab</span>:<span class='ident'>tt</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_skip</span>:<span class='ident'>tt</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>call_a_or_b_on_tail</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ab</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tail</span>)<span class='op'>*</span>)
    };
}

<span class='kw'>fn</span> <span class='ident'>compute_len</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>Some</span>(<span class='ident'>s</span>.<span class='ident'>len</span>())
}

<span class='kw'>fn</span> <span class='ident'>show_tail</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;tail: {:?}&quot;</span>, <span class='ident'>s</span>);
    <span class='prelude-val'>None</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(
        <span class='macro'>call_a_or_b_on_tail</span><span class='macro'>!</span>(
            (<span class='ident'>a</span>: <span class='ident'>compute_len</span>, <span class='ident'>b</span>: <span class='ident'>show_tail</span>),
            <span class='ident'>the</span> <span class='ident'>recursive</span> <span class='ident'>part</span> <span class='ident'>that</span> <span class='ident'>skips</span> <span class='ident'>over</span> <span class='ident'>all</span> <span class='ident'>these</span>
            <span class='ident'>tokens</span> <span class='ident'>doesn</span><span class='lifetime'>&#39;t</span> <span class='ident'>much</span> <span class='ident'>care</span> <span class='ident'>whether</span> <span class='ident'>we</span> <span class='ident'>will</span> <span class='ident'>call</span> <span class='ident'>a</span>
            <span class='ident'>or</span> <span class='ident'>call</span> <span class='ident'>b</span>: <span class='ident'>only</span> <span class='ident'>the</span> <span class='ident'>terminal</span> <span class='ident'>rules</span> <span class='ident'>care</span>.
        ),
        <span class='prelude-val'>None</span>
    );
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(
        <span class='macro'>call_a_or_b_on_tail</span><span class='macro'>!</span>(
            (<span class='ident'>a</span>: <span class='ident'>compute_len</span>, <span class='ident'>b</span>: <span class='ident'>show_tail</span>),
            <span class='ident'>and</span> <span class='ident'>now</span>, <span class='ident'>to</span> <span class='ident'>justify</span> <span class='ident'>the</span> <span class='ident'>existence</span> <span class='ident'>of</span> <span class='ident'>two</span> <span class='ident'>paths</span>
            <span class='ident'>we</span> <span class='ident'>will</span> <span class='ident'>also</span> <span class='ident'>call</span> <span class='ident'>a</span>: <span class='ident'>its</span> <span class='ident'>input</span> <span class='ident'>should</span> <span class='ident'>somehow</span>
            <span class='ident'>be</span> <span class='self'>self</span><span class='op'>-</span><span class='ident'>referential</span>, <span class='ident'>so</span> <span class='kw'>let</span><span class='lifetime'>&#39;s</span> <span class='ident'>make</span> <span class='ident'>it</span> <span class='kw'>return</span>
            <span class='ident'>some</span> <span class='ident'>ninety</span> <span class='macro'>one</span><span class='macro'>!</span>
        ),
        <span class='prelude-val'>Some</span>(<span class='number'>91</span>)
    );
}</pre>

<p>In particularly complex recursive macros, a large number of arguments may be needed in order to carry identifiers and expressions to successive layers.  However, depending on the implementation there may be many intermediate layers which need to forward these arguments, but do not need to <em>use</em> them.</p>

<p>As such, it can be very useful to bundle all such arguments together into a single TT by placing them in a group.  This allows layers which do not need to use the arguments to simply capture and substitute a single <code>tt</code>, rather than having to exactly capture and substitute the entire argument group.</p>

<p>The example above bundles the <code>$a</code> and <code>$b</code> expressions into a group which can then be forwarded as a single <code>tt</code> by the recursive rule.  This group is then destructured by the terminal rules to access the expressions.</p>

<h1 id="provisional" class='section-header'><a
                           href="#provisional">Provisional</a></h1>
<p>This section is for patterns or techniques which are of dubious value, or which might be <em>too</em> niche for inclusion.</p>

<h2 id="abacus-counters" class='section-header'><a
                           href="#abacus-counters">Abacus Counters</a></h2>
<blockquote>
<p><strong>Provisional</strong>: needs a more compelling example.  Although an important part of the <code>Ook!</code> macro, matching nested groups that are <em>not</em> denoted by Rust groups is sufficiently unusual that it may not merit inclusion.</p>

<p><strong>Note</strong>: this section assumes understanding of <a href="#push-down-accumulation">push-down accumulation</a> and <a href="#incremental-tt-munchers">incremental TT munchers</a>.</p>
</blockquote>
<span class='rusttest'>macro_rules! abacus {
    ((- $($moves:tt)*) -&gt; (+ $($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; ($($count)*))
    };
    ((- $($moves:tt)*) -&gt; ($($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; (- $($count)*))
    };
    ((+ $($moves:tt)*) -&gt; (- $($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; ($($count)*))
    };
    ((+ $($moves:tt)*) -&gt; ($($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; (+ $($count)*))
    };

    // Check if the final result is zero.
    (() -&gt; ()) =&gt; { true };
    (() -&gt; ($($count:tt)+)) =&gt; { false };
}

fn main() {
    let equals_zero = abacus!((++-+-+++--++---++----+) -&gt; ());
    assert_eq!(equals_zero, true);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>abacus</span> {
    ((<span class='op'>-</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>-&gt;</span> (<span class='op'>+</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>:<span class='ident'>tt</span>)<span class='op'>*</span>)) <span class='op'>=&gt;</span> {
        <span class='macro'>abacus</span><span class='macro'>!</span>(($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>)<span class='op'>*</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>)<span class='op'>*</span>))
    };
    ((<span class='op'>-</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>:<span class='ident'>tt</span>)<span class='op'>*</span>)) <span class='op'>=&gt;</span> {
        <span class='macro'>abacus</span><span class='macro'>!</span>(($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>)<span class='op'>*</span>) <span class='op'>-&gt;</span> (<span class='op'>-</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>)<span class='op'>*</span>))
    };
    ((<span class='op'>+</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>-&gt;</span> (<span class='op'>-</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>:<span class='ident'>tt</span>)<span class='op'>*</span>)) <span class='op'>=&gt;</span> {
        <span class='macro'>abacus</span><span class='macro'>!</span>(($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>)<span class='op'>*</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>)<span class='op'>*</span>))
    };
    ((<span class='op'>+</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>:<span class='ident'>tt</span>)<span class='op'>*</span>)) <span class='op'>=&gt;</span> {
        <span class='macro'>abacus</span><span class='macro'>!</span>(($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>)<span class='op'>*</span>) <span class='op'>-&gt;</span> (<span class='op'>+</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>)<span class='op'>*</span>))
    };

    <span class='comment'>// Check if the final result is zero.</span>
    (() <span class='op'>-&gt;</span> ()) <span class='op'>=&gt;</span> { <span class='boolval'>true</span> };
    (() <span class='op'>-&gt;</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>:<span class='ident'>tt</span>)<span class='op'>+</span>)) <span class='op'>=&gt;</span> { <span class='boolval'>false</span> };
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>equals_zero</span> <span class='op'>=</span> <span class='macro'>abacus</span><span class='macro'>!</span>((<span class='op'>+</span><span class='op'>+</span><span class='op'>-</span><span class='op'>+</span><span class='op'>-</span><span class='op'>+</span><span class='op'>+</span><span class='op'>+</span><span class='op'>-</span><span class='op'>-</span><span class='op'>+</span><span class='op'>+</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>+</span><span class='op'>+</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>+</span>) <span class='op'>-&gt;</span> ());
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>equals_zero</span>, <span class='boolval'>true</span>);
}</pre>

<p>This technique can be used in cases where you need to keep track of a varying counter that starts at or near zero, and must support the following operations:</p>

<ul>
<li>Increment by one.</li>
<li>Decrement by one.</li>
<li>Compare to zero (or any other fixed, finite value).</li>
</ul>

<p>A value of <em>n</em> is represented by <em>n</em> instances of a specific token stored in a group.  Modifications are done using recursion and <a href="#push-down-accumulation">push-down accumulation</a>.  Assuming the token used is <code>x</code>, the operations above are implemented as follows:</p>

<ul>
<li>Increment by one: match <code>($($count:tt)*)</code>, substitute <code>(x $($count)*)</code>.</li>
<li>Decrement by one: match <code>(x $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>Compare to zero: match <code>()</code>.</li>
<li>Compare to one: match <code>(x)</code>.</li>
<li>Compare to two: match <code>(x x)</code>.</li>
<li><em>(and so on...)</em></li>
</ul>

<p>In this way, operations on the counter are like flicking tokens back and forth like an abacus.<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<p>In cases where you want to represent negative values, <em>-n</em> can be represented as <em>n</em> instances of a <em>different</em> token.  In the example given above, <em>+n</em> is stored as <em>n</em> <code>+</code> tokens, and <em>-m</em> is stored as <em>m</em> <code>-</code> tokens.</p>

<p>In this case, the operations become slightly more complicated; increment and decrement effectively reverse their usual meanings when the counter is negative.  To whit given <code>+</code> and <code>-</code> for the positive and negative tokens respectively, the operations change to:</p>

<ul>
<li>Increment by one:

<ul>
<li>match <code>()</code>, substitute <code>(+)</code>.</li>
<li>match <code>(- $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>match <code>($($count:tt)+)</code>, substitute <code>(+ $($count)+)</code>.</li>
</ul></li>
<li>Decrement by one:

<ul>
<li>match <code>()</code>, substitute <code>(-)</code>.</li>
<li>match <code>(+ $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>match <code>($($count:tt)+)</code>, substitute <code>(- $($count)+)</code>.</li>
</ul></li>
<li>Compare to 0: match <code>()</code>.</li>
<li>Compare to +1: match <code>(+)</code>.</li>
<li>Compare to -1: match <code>(-)</code>.</li>
<li>Compare to +2: match <code>(++)</code>.</li>
<li>Compare to -2: match <code>(--)</code>.</li>
<li><em>(and so on...)</em></li>
</ul>

<p>Note that the example at the top combines some of the rules together (for example, it combines increment on <code>()</code> and <code>($($count:tt)+)</code> into an increment on <code>($($count:tt)*)</code>).</p>

<p>If you want to extract the actual <em>value</em> of the counter, this can be done using a regular <a href="../blk/README.html#counting">counter macro</a>.  For the example above, the terminal rules can be replaced with the following:</p>
<span class='rusttest'>fn main() {
    macro_rules! abacus {
        // ...
    
        // This extracts the counter as an integer expression.
        (() -&gt; ()) =&gt; {0};
        (() -&gt; (- $($count:tt)*)) =&gt; {
            {(-1i32) $(- replace_expr!($count 1i32))*}
        };
        (() -&gt; (+ $($count:tt)*)) =&gt; {
            {(1i32) $(+ replace_expr!($count 1i32))*}
        };
    }
    
    macro_rules! replace_expr {
        ($_t:tt $sub:expr) =&gt; {$sub};
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>abacus</span> {
    <span class='comment'>// ...</span>

    <span class='comment'>// This extracts the counter as an integer expression.</span>
    (() <span class='op'>-&gt;</span> ()) <span class='op'>=&gt;</span> {<span class='number'>0</span>};
    (() <span class='op'>-&gt;</span> (<span class='op'>-</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>:<span class='ident'>tt</span>)<span class='op'>*</span>)) <span class='op'>=&gt;</span> {
        {(<span class='op'>-</span><span class='number'>1i32</span>) $(<span class='op'>-</span> <span class='macro'>replace_expr</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span> <span class='number'>1i32</span>))<span class='op'>*</span>}
    };
    (() <span class='op'>-&gt;</span> (<span class='op'>+</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span>:<span class='ident'>tt</span>)<span class='op'>*</span>)) <span class='op'>=&gt;</span> {
        {(<span class='number'>1i32</span>) $(<span class='op'>+</span> <span class='macro'>replace_expr</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>count</span> <span class='number'>1i32</span>))<span class='op'>*</span>}
    };
}

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>replace_expr</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_t</span>:<span class='ident'>tt</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sub</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sub</span>};
}</pre>

<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: strictly speaking, the above formulation of <code>abacus!</code> is needlessly complex.  It can be implemented much more efficiently using repetition, provided you <em>do not</em> need to match against the counter&#39;s value in a macro:</p>
<span class='rusttest'>fn main() {
    macro_rules! abacus {
        (-) =&gt; {-1};
        (+) =&gt; {1};
        ($($moves:tt)*) =&gt; {
            0 $(+ abacus!($moves))*
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>abacus</span> {
    (<span class='op'>-</span>) <span class='op'>=&gt;</span> {<span class='op'>-</span><span class='number'>1</span>};
    (<span class='op'>+</span>) <span class='op'>=&gt;</span> {<span class='number'>1</span>};
    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        <span class='number'>0</span> $(<span class='op'>+</span> <span class='macro'>abacus</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>moves</span>))<span class='op'>*</span>
    }
}</pre>
</blockquote>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>This desperately thin reasoning conceals the <em>real</em> reason for this name: to avoid having <em>yet another</em> thing with &quot;token&quot; in the name.  Talk to your writer about avoiding <a href="https://en.wikipedia.org/wiki/Semantic_satiation">semantic satiation</a> today!&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>

<p>In fairness, it could <em>also</em> have been called <a href="https://en.wikipedia.org/wiki/Unary_numeral_system">&quot;unary counting&quot;</a>.</p>
</li>

</ol>
</div>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>
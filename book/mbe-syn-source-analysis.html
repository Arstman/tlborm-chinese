<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>源码解析过程</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='mbe-README.html'><b>2.</b> 宏，彻底剖析</a>
<ol class='section'>
<li><a  href='mbe-syn-README.html'><b>2.1.</b> 语法扩展</a>
<ol class='section'>
<li><a class='active' href='mbe-syn-source-analysis.html'><b>2.1.1.</b> 源码解析过程</a>
</li>
<li><a  href='mbe-syn-macros-in-the-ast.html'><b>2.1.2.</b> AST中的宏</a>
</li>
<li><a  href='mbe-syn-expansion.html'><b>2.1.3.</b> 展开</a>
</li>
</ol>
</li>
<li><a  href='mbe-macro-rules.html'><b>2.2.</b> macro_rules!</a>
</li>
<li><a  href='mbe-min-README.html'><b>2.3.</b> 细枝末节</a>
<ol class='section'>
<li><a  href='mbe-min-captures-and-expansion-redux.html'><b>2.3.1.</b> 再探捕获与展开</a>
</li>
<li><a  href='mbe-min-hygiene.html'><b>2.3.2.</b> 卫生性</a>
</li>
<li><a  href='mbe-min-non-identifier-identifiers.html'><b>2.3.3.</b> 不是标识符的标识符</a>
</li>
<li><a  href='mbe-min-debugging.html'><b>2.3.4.</b> 调试</a>
</li>
<li><a  href='mbe-min-scoping.html'><b>2.3.5.</b> 作用域</a>
</li>
<li><a  href='mbe-min-import-export.html'><b>2.3.6.</b> 导入/导出</a>
</li>
</ol>
</li>
</ol>
</li>
<li><a  href='pim-README.html'><b>3.</b> 宏，实践介绍</a>
</li>
<li><a  href='pat-README.html'><b>4.</b> Patterns</a>
<ol class='section'>
<li><a  href='pat-callbacks.html'><b>4.1.</b> Callbacks</a>
</li>
<li><a  href='pat-incremental-tt-munchers.html'><b>4.2.</b> Incremental TT Munchers</a>
</li>
<li><a  href='pat-internal-rules.html'><b>4.3.</b> Internal Rules</a>
</li>
<li><a  href='pat-push-down-accumulation.html'><b>4.4.</b> Push-Down Accumulation</a>
</li>
<li><a  href='pat-repetition-replacement.html'><b>4.5.</b> Repetition Replacement</a>
</li>
<li><a  href='pat-trailing-separators.html'><b>4.6.</b> Trailing Separators</a>
</li>
<li><a  href='pat-tt-bundling.html'><b>4.7.</b> TT Bundling</a>
</li>
<li><a  href='pat-visibility.html'><b>4.8.</b> Visibility</a>
</li>
<li><a  href='pat-provisional.html'><b>4.9.</b> Provisional</a>
</li>
</ol>
</li>
<li><a  href='blk-README.html'><b>5.</b> Building Blocks</a>
<ol class='section'>
<li><a  href='blk-ast-coercion.html'><b>5.1.</b> AST Coercion</a>
</li>
<li><a  href='blk-counting.html'><b>5.2.</b> Counting</a>
</li>
<li><a  href='blk-enum-parsing.html'><b>5.3.</b> Enum Parsing</a>
</li>
</ol>
</li>
<li><a  href='aeg-README.html'><b>6.</b> Annotated Examples</a>
<ol class='section'>
<li><a  href='aeg-ook.html'><b>6.1.</b> Ook!</a>
</li>
</ol>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">源码解析过程</h1>
    <p>Rust程序编译过程的第一阶段是标记解析(tokenization)。在这一过程中，源代码将被转换成一系列的标记(token，即无法被分割的词法单元；在编程语言世界中等价于“单词”)。Rust包含多种标记，比如：</p>

<ul>
<li>标识符(identifiers)：<code>foo</code>, <code>Bambous</code>, <code>self</code>, <code>we_can_dance</code>, <code>LaCaravane</code>, …</li>
<li>整数(integers)：<code>42</code>, <code>72u32</code>, <code>0_______0</code>, …</li>
<li>关键词(keywords)：<code>_</code>, <code>fn</code>, <code>self</code>, <code>match</code>, <code>yield</code>, <code>macro</code>, …</li>
<li>生命周期(lifetimes)：<code>&#39;a</code>, <code>&#39;b</code>, <code>&#39;a_rare_long_lifetime_name</code>, …</li>
<li>字符串(strings)：<code>&quot;&quot;</code>, <code>&quot;Leicester&quot;</code>, <code>r##&quot;venezuelan beaver&quot;##</code>, …</li>
<li>符号(symbols)：<code>[</code>, <code>:</code>, <code>::</code>, <code>-&gt;</code>, <code>@</code>, <code>&lt;-</code>, …</li>
</ul>

<p>…等等。</p>

<p>上面的叙述中有些地方值得注意。</p>

<p>首先，<code>self</code>既是一个标识符又是一个关键词。几乎在所有情况下它都被视作是一个关键词，但它**有可能**被视为标识符。我们稍后会（带着咒骂）提到这种情况。</p>

<p>其次，关键词里列有一些可疑的家伙，比如<code>yield</code>和<code>macro</code>。它们在当前的Rust语言中并没有任何含义，但编译器的确会把它们视作关键词进行转义。这些词语被保留作语言未来扩充时使用。</p>

<p>第三，符号里**也**列有一些未被当前语言使用的条目。比如<code>&lt;-</code>，这是历史残留：目前它被移除了Rust语法，但词法分析器仍然没丢掉它。</p>

<p>最后，注意<code>::</code>被视作一个独立的标记，而非两个连续的<code>:</code>。这一规则适用于Rust中所有的多字符符号标记。<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<p>作为对比，某些语言的宏系统正扎根于这一阶段。Rust并非如此。举例来说，从效果来看，C/C++的宏就是在这里得到处理的。<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>这也正是下列代码能够运行的原因:<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup></p>

<pre><code class="language-c">#define SUB void
#define BEGIN {
#define END }

SUB main() BEGIN
    printf(&quot;Oh, the horror!\n&quot;);
END
</code></pre>

<p>编译过程的下一个阶段是语法解析(parsing)。这一过程中，一系列的标记将被转换成一棵抽象语法树(Abstract Syntax Tree, AST)。此过程将在内存中建立起程序的语法结构。举例来说，标记序列<code>1+2</code>将被转换成某种类似于:</p>

<pre><code class="language-text">┌─────────┐   ┌─────────┐
│ BinOp   │ ┌╴│ LitInt  │
│ op: Add │ │ │ val: 1  │
│ lhs: ◌  │╶┘ └─────────┘
│ rhs: ◌  │╶┐ ┌─────────┐
└─────────┘ └╴│ LitInt  │
              │ val: 2  │
              └─────────┘
</code></pre>

<p>的东西。生成出的AST将包含**整个**程序的结构，但这一结构仅包含**词法**信息。举例来讲，在这个阶段编译器虽然可能知道某个表达式提及了某个名为<code>a</code>的变量，但它并**没有**办法知道<code>a</code>究竟是什么，或者它在哪儿。</p>

<p>在AST生成**之后**，宏处理过程才开始。但在讨论宏处理过程之前，我们需要先谈谈标记树(token tree)。</p>

<h2 id='标记树' class='section-header'><a href='#标记树'>标记树</a></h2>
<p>标记树是介于标记与AST之间的东西。首先明确一点，**几乎所有**标记都构成标记树。具体来说，它们可被看作标记树叶节点。另有一类存在可被看作标记树叶节点，我们将在稍后提到它。</p>

<p>只有一种基础标记**不是**标记树叶节点，“分组”标记：<code>(...)</code>， <code>[...]</code>和<code>{...}</code>。这三者属于标记树内节点， 正是它们给标记树带来了树状的结构。给个具体的例子，这列标记：</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span> <span class='op'>+</span> (<span class='ident'>c</span> <span class='op'>+</span> <span class='ident'>d</span>[<span class='number'>0</span>]) <span class='op'>+</span> <span class='ident'>e</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aa%20%2B%20b%20%2B%20(c%20%2B%20d%5B0%5D)%20%2B%20e%0A%7D">Run</a></pre>

<p>将被转换为这样的标记树：</p>

<pre><code class="language-text">«a» «+» «b» «+» «(   )» «+» «e»
          ╭────────┴──────────╮
           «c» «+» «d» «[   ]»
                        ╭─┴─╮
                         «0»
</code></pre>

<p>注意它跟最后生成的AST并没有关联。AST将仅有一个根节点，而这棵标记树有九（原文如此）个。作为参照，最后生成的AST应该是这样：</p>

<pre><code class="language-text">              ┌─────────┐
              │ BinOp   │
              │ op: Add │
            ┌╴│ lhs: ◌  │
┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
│ Var     │╶┘ └─────────┘ └╴│ BinOp   │
│ name: a │                 │ op: Add │
└─────────┘               ┌╴│ lhs: ◌  │
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ BinOp   │
              │ name: b │                 │ op: Add │
              └─────────┘               ┌╴│ lhs: ◌  │
                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │
                            │ op: Add │                 │ name: e │
                          ┌╴│ lhs: ◌  │                 └─────────┘
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ Index   │
              │ name: c │               ┌╴│ arr: ◌  │
              └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐ ┌─────────┐
                            │ Var     │╶┘ └─────────┘ └╴│ LitInt  │
                            │ name: d │                 │ val: 0  │
                            └─────────┘                 └─────────┘
</code></pre>

<p>理解AST与标记树间的区别至关重要。写宏时，你将同时与这两者打交道。</p>

<p>还有一条需要注意：不可能出现不匹配的小/中/大括号，也不可能存在包含错误嵌套结构的标记树。</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p><code>@</code>是有意义的，虽然大多数人好像都已经完全不记得它了。它用于在模式中把某个模式的非终结部分绑定给一个名称。甚至一位Rust核心团队的成员，在审阅这一章节并特意提起这一小节时，都没记起它的含义。可怜，真是可怜。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>事实上，C的预处理器采用了跟C语言本身不同的词法结构。但总体来说个中区别并不相干。&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>它是不是真该奏效又是另外一码事了。&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>再探捕获与展开</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='mbe-README.html'><b>2.</b> 宏，彻底剖析</a>
<ol class='section'>
<li><a  href='mbe-syn-README.html'><b>2.1.</b> 语法扩展</a>
<ol class='section'>
<li><a  href='mbe-syn-source-analysis.html'><b>2.1.1.</b> 源码解析过程</a>
</li>
<li><a  href='mbe-syn-macros-in-the-ast.html'><b>2.1.2.</b> AST中的宏</a>
</li>
<li><a  href='mbe-syn-expansion.html'><b>2.1.3.</b> 展开</a>
</li>
</ol>
</li>
<li><a  href='mbe-macro-rules.html'><b>2.2.</b> macro_rules!</a>
</li>
<li><a  href='mbe-min-README.html'><b>2.3.</b> 细枝末节</a>
<ol class='section'>
<li><a class='active' href='mbe-min-captures-and-expansion-redux.html'><b>2.3.1.</b> 再探捕获与展开</a>
</li>
<li><a  href='mbe-min-hygiene.html'><b>2.3.2.</b> 卫生性</a>
</li>
<li><a  href='mbe-min-non-identifier-identifiers.html'><b>2.3.3.</b> 不是标识符的标识符</a>
</li>
<li><a  href='mbe-min-debugging.html'><b>2.3.4.</b> 调试</a>
</li>
<li><a  href='mbe-min-scoping.html'><b>2.3.5.</b> 作用域</a>
</li>
<li><a  href='mbe-min-import-export.html'><b>2.3.6.</b> 导入/导出</a>
</li>
</ol>
</li>
</ol>
</li>
<li><a  href='pim-README.html'><b>3.</b> 宏，实践介绍</a>
</li>
<li><a  href='pat-README.html'><b>4.</b> Patterns</a>
<ol class='section'>
<li><a  href='pat-callbacks.html'><b>4.1.</b> Callbacks</a>
</li>
<li><a  href='pat-incremental-tt-munchers.html'><b>4.2.</b> Incremental TT Munchers</a>
</li>
<li><a  href='pat-internal-rules.html'><b>4.3.</b> Internal Rules</a>
</li>
<li><a  href='pat-push-down-accumulation.html'><b>4.4.</b> Push-Down Accumulation</a>
</li>
<li><a  href='pat-repetition-replacement.html'><b>4.5.</b> Repetition Replacement</a>
</li>
<li><a  href='pat-trailing-separators.html'><b>4.6.</b> Trailing Separators</a>
</li>
<li><a  href='pat-tt-bundling.html'><b>4.7.</b> TT Bundling</a>
</li>
<li><a  href='pat-visibility.html'><b>4.8.</b> Visibility</a>
</li>
<li><a  href='pat-provisional.html'><b>4.9.</b> Provisional</a>
</li>
</ol>
</li>
<li><a  href='blk-README.html'><b>5.</b> Building Blocks</a>
<ol class='section'>
<li><a  href='blk-ast-coercion.html'><b>5.1.</b> AST Coercion</a>
</li>
<li><a  href='blk-counting.html'><b>5.2.</b> Counting</a>
</li>
<li><a  href='blk-enum-parsing.html'><b>5.3.</b> Enum Parsing</a>
</li>
</ol>
</li>
<li><a  href='aeg-README.html'><b>6.</b> Annotated Examples</a>
<ol class='section'>
<li><a  href='aeg-ook.html'><b>6.1.</b> Ook!</a>
</li>
</ol>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">再探捕获与展开</h1>
    <p>一旦语法分析器开始消耗标记以匹配某捕获，整个过程便无法停止或回溯。这意味着，下述宏的第二项规则将永远无法被匹配到，无论输入是什么样的：</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>dead_rule</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> { ... };
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>i</span>:<span class='ident'>ident</span> <span class='op'>+</span>) <span class='op'>=&gt;</span> { ... };
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amacro_rules!%20dead_rule%20%7B%0A%20%20%20%20(%24e%3Aexpr)%20%3D%3E%20%7B%20...%20%7D%3B%0A%20%20%20%20(%24i%3Aident%20%2B)%20%3D%3E%20%7B%20...%20%7D%3B%0A%7D%0A%7D">Run</a></pre>

<p>考虑当以<code>dead_rule!(x+)</code>形式调用此宏时，将会发生什么。解析器将从第一条规则开始试图进行匹配：它试图将输入解析为一个表达式；第一个标记(<code>x</code>)作为表达式是有效的，第二个标记——作为二元加的节点——在表达式中也是有效的。</p>

<p>至此，由于输入中并不包含二元加的右手侧元素，你可能会以为，分析器将会放弃尝试这一规则，转而尝试下一条规则。实则不然：分析器将会<code>panic</code>并终止整个编译过程，返回一个语法错误。</p>

<p>由于分析器的这一特点，下面这点尤为重要：一般而言，在书写宏规则时，应从最具体的开始写起，依次写至最不具体的。</p>

<p>为防范未来宏输入的解读方式改变所可能带来的句法影响，<code>macro_rules!</code>对各式捕获之后所允许的内容施加了诸多限制。在Rust1.3下，完整的列表如下：</p>

<ul>
<li><code>item</code>: 任何标记</li>
<li><code>block</code>: 任何标记</li>
<li><code>stmt</code>: <code>=&gt;</code> <code>、</code> <code>;</code></li>
<li><code>pat</code>: <code>=&gt;</code> <code>、</code> <code>=</code>、 <code>if</code>、 <code>in</code></li>
<li><code>expr</code>: <code>=&gt;</code> <code>、</code> <code>;</code></li>
<li><code>ty</code>: <code>,</code>、 <code>=&gt;</code>、 <code>:</code>、 <code>=</code>、 <code>&gt;</code>、 <code>;</code>、 <code>as</code></li>
<li><code>ident</code>: 任何标记</li>
<li><code>path</code>: <code>,</code>、 <code>=&gt;</code>、 <code>:</code>、 <code>=</code>、 <code>&gt;</code>、 <code>;</code>、 <code>as</code></li>
<li><code>meta</code>: 任何标记</li>
<li><code>tt</code>: 任何标记</li>
</ul>

<p>此外，<code>macro_rules!</code> 通常不允许一个重复紧跟在另一重复之后，即便它们的内容并不冲突。</p>

<p>有一条关于替换的特征经常引人惊奇：尽管看起来很像，但替换**并非**基于标记(token-based)的。下例展示了这一点：</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>capture_expr_then_stringify</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>)
    };
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='ident'>dummy</span>(<span class='number'>2</span> <span class='op'>*</span> (<span class='number'>1</span> <span class='op'>+</span> (<span class='number'>3</span>)))));
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='macro'>capture_expr_then_stringify</span><span class='macro'>!</span>(<span class='ident'>dummy</span>(<span class='number'>2</span> <span class='op'>*</span> (<span class='number'>1</span> <span class='op'>+</span> (<span class='number'>3</span>)))));
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20capture_expr_then_stringify%20%7B%0A%20%20%20%20(%24e%3Aexpr)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20stringify!(%24e)%0A%20%20%20%20%7D%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20stringify!(dummy(2%20*%20(1%20%2B%20(3)))))%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20capture_expr_then_stringify!(dummy(2%20*%20(1%20%2B%20(3)))))%3B%0A%7D%0A">Run</a></pre>

<p>注意到<code>stringify!</code>，这是一条内置的语法扩充，将所有输入标记结合在一起，作为单个字符串输出。</p>

<p>上述代码的输出将是：</p>

<pre><code class="language-text">&quot;dummy ( 2 * ( 1 + ( 3 ) ) )&quot;
&quot;dummy(2 * (1 + (3)))&quot;
</code></pre>

<p>尽管二者的输入完全一致，它们的输出并不相同。这是因为，前者字符串化的是一列标记树，而后者字符串化的则是一个AST表达式节点。</p>

<p>我们另用一种方式展现二者的不同。第一种情况下，<code>stringify!</code>被调用时，输入是：</p>

<pre><code class="language-text">«dummy» «(   )»
   ╭───────┴───────╮
    «2» «*» «(   )»
       ╭───────┴───────╮
        «1» «+» «(   )»
                 ╭─┴─╮
                  «3»
</code></pre>

<p>…而第二种情况下，<code>stringify!</code>被调用时，输入是：</p>

<pre><code class="language-text">« »
 │ ┌─────────────┐
 └╴│ Call        │
   │ fn: dummy   │   ┌─────────┐
   │ args: ◌     │╶─╴│ BinOp   │
   └─────────────┘   │ op: Mul │
                   ┌╴│ lhs: ◌  │
        ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
        │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
        │ val: 2 │                 │ op: Add │
        └────────┘               ┌╴│ lhs: ◌  │
                      ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                      │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                      │ val: 1 │                 │ val: 3 │
                      └────────┘                 └────────┘
</code></pre>

<p>如图所示，第二种情况下，输入仅有一棵标记树，它包含了一棵AST，这棵AST则是在解析<code>capture_expr_then_stringify!</code>的调用时，调用的输入经解析后所得的输出。因此，在这种情况下，我们最终看到的是字符串化AST节点所得的输出，而非字符串化标记所得的输出。</p>

<p>这一特征还有更加深刻的影响。考虑如下代码段：</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>capture_then_match_tokens</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro'>match_tokens</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>)};
}

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>match_tokens</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>a</span>:<span class='ident'>tt</span> <span class='op'>+</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>b</span>:<span class='ident'>tt</span>) <span class='op'>=&gt;</span> {<span class='string'>&quot;got an addition&quot;</span>};
    ((<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>i</span>:<span class='ident'>ident</span>)) <span class='op'>=&gt;</span> {<span class='string'>&quot;got an identifier&quot;</span>};
    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>other</span>:<span class='ident'>tt</span>)<span class='kw-2'>*</span>) <span class='op'>=&gt;</span> {<span class='string'>&quot;got something else&quot;</span>};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}\n{}\n{}\n&quot;</span>,
        <span class='macro'>match_tokens</span><span class='macro'>!</span>((<span class='ident'>caravan</span>)),
        <span class='macro'>match_tokens</span><span class='macro'>!</span>(<span class='number'>3</span> <span class='op'>+</span> <span class='number'>6</span>),
        <span class='macro'>match_tokens</span><span class='macro'>!</span>(<span class='number'>5</span>));
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}\n{}\n{}&quot;</span>,
        <span class='macro'>capture_then_match_tokens</span><span class='macro'>!</span>((<span class='ident'>caravan</span>)),
        <span class='macro'>capture_then_match_tokens</span><span class='macro'>!</span>(<span class='number'>3</span> <span class='op'>+</span> <span class='number'>6</span>),
        <span class='macro'>capture_then_match_tokens</span><span class='macro'>!</span>(<span class='number'>5</span>));
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20capture_then_match_tokens%20%7B%0A%20%20%20%20(%24e%3Aexpr)%20%3D%3E%20%7Bmatch_tokens!(%24e)%7D%3B%0A%7D%0A%0Amacro_rules!%20match_tokens%20%7B%0A%20%20%20%20(%24a%3Att%20%2B%20%24b%3Att)%20%3D%3E%20%7B%22got%20an%20addition%22%7D%3B%0A%20%20%20%20((%24i%3Aident))%20%3D%3E%20%7B%22got%20an%20identifier%22%7D%3B%0A%20%20%20%20(%24(%24other%3Att)*)%20%3D%3E%20%7B%22got%20something%20else%22%7D%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%5Cn%7B%7D%5Cn%7B%7D%5Cn%22%2C%0A%20%20%20%20%20%20%20%20match_tokens!((caravan))%2C%0A%20%20%20%20%20%20%20%20match_tokens!(3%20%2B%206)%2C%0A%20%20%20%20%20%20%20%20match_tokens!(5))%3B%0A%20%20%20%20println!(%22%7B%7D%5Cn%7B%7D%5Cn%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20capture_then_match_tokens!((caravan))%2C%0A%20%20%20%20%20%20%20%20capture_then_match_tokens!(3%20%2B%206)%2C%0A%20%20%20%20%20%20%20%20capture_then_match_tokens!(5))%3B%0A%7D%0A">Run</a></pre>

<p>其输出将是：</p>

<pre><code class="language-text">got an identifier
got an addition
got something else

got something else
got something else
got something else
</code></pre>

<p>因为输入被解析为AST节点，替换所得的结果将无法析构。也就是说，你没办法检查其内容，或是再按原先相符的匹配匹配它。</p>

<p>接下来这个例子尤其可能让人感到不解：</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>capture_then_what_is</span> {
    (<span class='attribute'>#[<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>m</span>:<span class='ident'>meta</span>]</span>) <span class='op'>=&gt;</span> {<span class='macro'>what_is</span><span class='macro'>!</span>(<span class='attribute'>#[<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>m</span>]</span>)};
}

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>what_is</span> {
    (<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>) <span class='op'>=&gt;</span> {<span class='string'>&quot;no_mangle attribute&quot;</span>};
    (<span class='attribute'>#[<span class='ident'>inline</span>]</span>) <span class='op'>=&gt;</span> {<span class='string'>&quot;inline attribute&quot;</span>};
    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tts</span>:<span class='ident'>tt</span>)<span class='kw-2'>*</span>) <span class='op'>=&gt;</span> {<span class='macro'>concat</span><span class='macro'>!</span>(<span class='string'>&quot;something else (&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tts</span>)<span class='kw-2'>*</span>), <span class='string'>&quot;)&quot;</span>)};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(
        <span class='string'>&quot;{}\n{}\n{}\n{}&quot;</span>,
        <span class='macro'>what_is</span><span class='macro'>!</span>(<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>),
        <span class='macro'>what_is</span><span class='macro'>!</span>(<span class='attribute'>#[<span class='ident'>inline</span>]</span>),
        <span class='macro'>capture_then_what_is</span><span class='macro'>!</span>(<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>),
        <span class='macro'>capture_then_what_is</span><span class='macro'>!</span>(<span class='attribute'>#[<span class='ident'>inline</span>]</span>),
    );
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20capture_then_what_is%20%7B%0A%20%20%20%20(%23%5B%24m%3Ameta%5D)%20%3D%3E%20%7Bwhat_is!(%23%5B%24m%5D)%7D%3B%0A%7D%0A%0Amacro_rules!%20what_is%20%7B%0A%20%20%20%20(%23%5Bno_mangle%5D)%20%3D%3E%20%7B%22no_mangle%20attribute%22%7D%3B%0A%20%20%20%20(%23%5Binline%5D)%20%3D%3E%20%7B%22inline%20attribute%22%7D%3B%0A%20%20%20%20(%24(%24tts%3Att)*)%20%3D%3E%20%7Bconcat!(%22something%20else%20(%22%2C%20stringify!(%24(%24tts)*)%2C%20%22)%22)%7D%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%5Cn%7B%7D%5Cn%7B%7D%5Cn%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20what_is!(%23%5Bno_mangle%5D)%2C%0A%20%20%20%20%20%20%20%20what_is!(%23%5Binline%5D)%2C%0A%20%20%20%20%20%20%20%20capture_then_what_is!(%23%5Bno_mangle%5D)%2C%0A%20%20%20%20%20%20%20%20capture_then_what_is!(%23%5Binline%5D)%2C%0A%20%20%20%20)%3B%0A%7D%0A">Run</a></pre>

<p>输出将是：</p>

<pre><code class="language-text">no_mangle attribute
inline attribute
something else (# [ no_mangle ])
something else (# [ inline ])
</code></pre>

<p>得以幸免的捕获只有<code>tt</code>或<code>ident</code>两种。其余的任何捕获，一经替换，结果将只能被用于直接输出。</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>展开</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='mbe-README.html'><b>2.</b> 宏，彻底剖析</a>
<ol class='section'>
<li><a  href='mbe-syn-README.html'><b>2.1.</b> 语法扩展</a>
<ol class='section'>
<li><a  href='mbe-syn-source-analysis.html'><b>2.1.1.</b> 源码解析过程</a>
</li>
<li><a  href='mbe-syn-macros-in-the-ast.html'><b>2.1.2.</b> AST中的宏</a>
</li>
<li><a class='active' href='mbe-syn-expansion.html'><b>2.1.3.</b> 展开</a>
</li>
</ol>
</li>
<li><a  href='mbe-macro-rules.html'><b>2.2.</b> macro_rules!</a>
</li>
<li><a  href='mbe-min-README.html'><b>2.3.</b> 细枝末节</a>
<ol class='section'>
<li><a  href='mbe-min-captures-and-expansion-redux.html'><b>2.3.1.</b> 再探捕获与展开</a>
</li>
<li><a  href='mbe-min-hygiene.html'><b>2.3.2.</b> 卫生性</a>
</li>
<li><a  href='mbe-min-non-identifier-identifiers.html'><b>2.3.3.</b> 不是标识符的标识符</a>
</li>
<li><a  href='mbe-min-debugging.html'><b>2.3.4.</b> 调试</a>
</li>
<li><a  href='mbe-min-scoping.html'><b>2.3.5.</b> 作用域</a>
</li>
<li><a  href='mbe-min-import-export.html'><b>2.3.6.</b> 导入/导出</a>
</li>
</ol>
</li>
</ol>
</li>
<li><a  href='pim-README.html'><b>3.</b> 宏，实践介绍</a>
</li>
<li><a  href='pat-README.html'><b>4.</b> 常用模式</a>
<ol class='section'>
<li><a  href='pat-callbacks.html'><b>4.1.</b> 回调</a>
</li>
<li><a  href='pat-incremental-tt-munchers.html'><b>4.2.</b> 标记树撕咬机</a>
</li>
<li><a  href='pat-internal-rules.html'><b>4.3.</b> 内用规则</a>
</li>
<li><a  href='pat-push-down-accumulation.html'><b>4.4.</b> 下推累积</a>
</li>
<li><a  href='pat-repetition-replacement.html'><b>4.5.</b> 重复替代</a>
</li>
<li><a  href='pat-trailing-separators.html'><b>4.6.</b> 尾部分隔符</a>
</li>
<li><a  href='pat-tt-bundling.html'><b>4.7.</b> 标记树聚束</a>
</li>
<li><a  href='pat-visibility.html'><b>4.8.</b> 可见性</a>
</li>
<li><a  href='pat-provisional.html'><b>4.9.</b> 临时措施</a>
</li>
</ol>
</li>
<li><a  href='blk-README.html'><b>5.</b> 轮子</a>
<ol class='section'>
<li><a  href='blk-ast-coercion.html'><b>5.1.</b> AST强转</a>
</li>
<li><a  href='blk-counting.html'><b>5.2.</b> 计数</a>
</li>
<li><a  href='blk-enum-parsing.html'><b>5.3.</b> 枚举解析</a>
</li>
</ol>
</li>
<li><a  href='aeg-README.html'><b>6.</b> 实例注解</a>
<ol class='section'>
<li><a  href='aeg-ook.html'><b>6.1.</b> Ook!</a>
</li>
</ol>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">展开</h1>
    <p>展开相对简单。编译器在生成AST之后，对程序进行语义理解之前的某个时间点，将会对所有宏进行展开。</p>

<p>这一过程包括，遍历AST，定位所有宏调用，并将它们用其展开进行替换。在非宏的语法扩展情境中，此过程具体如何发生根据具体情境各有不同。但所有语法扩展在展开完成之后所经历的历程都与宏所经历的相同。</p>

<p>每当编译器遇见一个语法扩展，都会根据上下文决定一个语法元素集。该语法扩展的展开结果应能被顺利解析为集合中的某个元素。举例来说，如果在模组作用域内调用了宏，那么编译器就会尝试将该宏的展开结果解析为一个表示某项条目(item)的AST节点。如果在需要表达式的位置调用了宏，那么编译器就会尝试将该宏的展开结果解析为一个表示表达式的AST节点。</p>

<p>事实上，语义扩展能够被转换成以下任意一种：</p>

<ul>
<li>一个表达式，</li>
<li>一个模式，</li>
<li>0或多个条目，</li>
<li>0或多个<code>impl</code>条目，</li>
<li>0或多个语句。</li>
</ul>

<p>换句话讲，宏调用所在的位置，决定了该宏展开之后的结果被解读的方式。</p>

<p>编译器将把AST中表示宏调用的节点用其宏展开的输出节点完全替换。这一替换是结构性(structural)的，而非织构性(textural)的。</p>

<p>举例来说：</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>eight</span> <span class='op'>=</span> <span class='number'>2</span> <span class='op'>*</span> <span class='macro'>four</span><span class='macro'>!</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20eight%20%3D%202%20*%20four!()%3B%0A%7D">Run</a></pre>

<p>我们可将这部分AST表示为：</p>

<pre><code class="language-text">┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │
     │ val: 2 │                 │ name: four │
     └────────┘                 │ body: ()   │
                                └────────────┘
</code></pre>

<p>根据上下文，<code>four!()</code><strong>必须</strong>展开成一个表达式 (初始化语句只可能是表达式)。因此，无论实际展开结果如何，它都将被解读成一个完整的表达式。此处我们假设，<code>four!</code>的定义保证它被展开为表达式 <code>1 + 3</code>。故而，展开这一宏调用将使整个AST变为</p>

<pre><code class="language-text">┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
     │ val: 2 │                 │ op: Add │
     └────────┘               ┌╴│ lhs: ◌  │
                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                   │ val: 1 │                 │ val: 3 │
                   └────────┘                 └────────┘
</code></pre>

<p>这又能被重写成</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>eight</span> <span class='op'>=</span> <span class='number'>2</span> <span class='op'>*</span> (<span class='number'>1</span> <span class='op'>+</span> <span class='number'>3</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20eight%20%3D%202%20*%20(1%20%2B%203)%3B%0A%7D">Run</a></pre>

<p>注意到虽然表达式本身不包含括号，我们仍加上了它们。这是因为，编译器总是将宏展开结果作为完整的AST节点对待，而<b>不是</b>仅仅作为一列标记。换句话说，即便不显式地把复杂的表达式用括号包起来，编译器也不可能“错意”宏替换的结果，或者改变求值顺序。</p>

<p>理解这一点——宏展开被当作AST节点看待——非常重要，它表明：</p>

<ul>
<li>宏调用不仅可用的位置有限，其展开结果也只可能跟语法分析器在该位置所预期的AST节点种类相符合。</li>
<li>因此，宏**必定无法**展开成不完整或不合语法的架构。</li>
</ul>

<p>有关展开还有一条值得注意：如果某个语法扩展的展开结果包含了另一次语法扩展调用，那会怎么样？例如，上述<code>four!</code>如果被展开成了<code>1 + three!()</code>，会发生什么?</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='macro'>four</span><span class='macro'>!</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%20four!()%3B%0A%7D">Run</a></pre>

<p>展开成：</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1</span> <span class='op'>+</span> <span class='macro'>three</span><span class='macro'>!</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%201%20%2B%20three!()%3B%0A%7D">Run</a></pre>

<p>编译器将会检查扩展结果中是否包含更多的宏调用；如果有，它们将被进一步展开。因此，上述AST节点将被再次展开成：</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1</span> <span class='op'>+</span> <span class='number'>3</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%201%20%2B%203%3B%0A%7D">Run</a></pre>

<p>此处我们了解到，展开是按“趟”发生的；要多少趟才能完全展开所有调用，那就会展开多少趟。</p>

<p>嗯，也不全是如此。事实上，编译器为此设置了一个上限。它被称作宏递归上限，默认值为32.如果第32次展开结果仍然包含宏调用，编译器将会终止并返回一个递归上限溢出的错误信息。</p>

<p>此上限可通过属性 <code>#![recursion_limit=&quot;…&quot;]</code>被改写，但这种改写必须是crate级别的。 一般来讲，可能的话最好还是尽量让宏展开递归次数保持在默认值以下。</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Scoping</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='mbe-README.html'><b>2.</b> Macros, A Methodical Introduction</a>
<ul class='section'>
<li><a  href='mbe-syn-README.html'><b>2.1.</b> Syntax Extensions</a>
<ul class='section'>
<li><a  href='mbe-syn-source-analysis.html'><b>2.1.1.</b> Source Analysis</a>
</li>
<li><a  href='mbe-syn-macros-in-the-ast.html'><b>2.1.2.</b> Macros in the AST</a>
</li>
<li><a  href='mbe-syn-expansion.html'><b>2.1.3.</b> Expansion</a>
</li>
</ul>
</li>
<li><a  href='mbe-macro-rules.html'><b>2.2.</b> macro_rules!</a>
</li>
<li><a  href='mbe-min-README.html'><b>2.3.</b> Minutiae</a>
<ul class='section'>
<li><a  href='mbe-min-captures-and-expansion-redux.html'><b>2.3.1.</b> Captures and Expansion Redux</a>
</li>
<li><a  href='mbe-min-hygiene.html'><b>2.3.2.</b> Hygiene</a>
</li>
<li><a  href='mbe-min-non-identifier-identifiers.html'><b>2.3.3.</b> Non-Identifier Identifiers</a>
</li>
<li><a  href='mbe-min-debugging.html'><b>2.3.4.</b> Debugging</a>
</li>
<li><a class='active' href='mbe-min-scoping.html'><b>2.3.5.</b> Scoping</a>
</li>
<li><a  href='mbe-min-import-export.html'><b>2.3.6.</b> Import/Export</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='pim-README.html'><b>3.</b> Macros, A Practical Introduction</a>
</li>
<li><a  href='pat-README.html'><b>4.</b> Patterns</a>
<ul class='section'>
<li><a  href='pat-callbacks.html'><b>4.1.</b> Callbacks</a>
</li>
<li><a  href='pat-incremental-tt-munchers.html'><b>4.2.</b> Incremental TT Munchers</a>
</li>
<li><a  href='pat-internal-rules.html'><b>4.3.</b> Internal Rules</a>
</li>
<li><a  href='pat-push-down-accumulation.html'><b>4.4.</b> Push-Down Accumulation</a>
</li>
<li><a  href='pat-repetition-replacement.html'><b>4.5.</b> Repetition Replacement</a>
</li>
<li><a  href='pat-trailing-separators.html'><b>4.6.</b> Trailing Separators</a>
</li>
<li><a  href='pat-tt-bundling.html'><b>4.7.</b> TT Bundling</a>
</li>
<li><a  href='pat-visibility.html'><b>4.8.</b> Visibility</a>
</li>
<li><a  href='pat-provisional.html'><b>4.9.</b> Provisional</a>
</li>
</ul>
</li>
<li><a  href='blk-README.html'><b>5.</b> Building Blocks</a>
<ul class='section'>
<li><a  href='blk-ast-coercion.html'><b>5.1.</b> AST Coercion</a>
</li>
<li><a  href='blk-counting.html'><b>5.2.</b> Counting</a>
</li>
<li><a  href='blk-enum-parsing.html'><b>5.3.</b> Enum Parsing</a>
</li>
</ul>
</li>
<li><a  href='aeg-README.html'><b>6.</b> Annotated Examples</a>
<ul class='section'>
<li><a  href='aeg-ook.html'><b>6.1.</b> Ook!</a>
</li>
</ul>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Scoping</h1>
    <p>The way in which macros are scoped can be somewhat unintuitive.  Firstly, unlike everything else in the languages, macros will remain visible in sub-modules.</p>

<span class='rusttest'>macro_rules! X { () =&gt; {}; }
mod a {
    X!(); // defined
}
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>X</span> { () <span class='op'>=&gt;</span> {}; }
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined</span>
}
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined</span>
}
<span class='kw'>mod</span> <span class='ident'>c</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined</span>
}</pre>

<blockquote>
<p><strong>Note</strong>: In these examples, remember that all of them have the <em>same behaviour</em> when the module contents are in separate files.</p>
</blockquote>

<p>Secondly, <em>also</em> unlike everything else in the language, macros are only accessible <em>after</em> their definition.  Also note that this example demonstrates how macros do not &quot;leak&quot; out of their defining scope:</p>

<span class='rusttest'>mod a {
    // X!(); // undefined
}
mod b {
    // X!(); // undefined
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    // X!(); // undefined
}
fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='comment'>// X!(); // undefined</span>
}
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='comment'>// X!(); // undefined</span>
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>X</span> { () <span class='op'>=&gt;</span> {}; }
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined</span>
}
<span class='kw'>mod</span> <span class='ident'>c</span> {
    <span class='comment'>// X!(); // undefined</span>
}</pre>

<p>To be clear, this lexical order dependency applies even if you move the macro to an outer scope:</p>

<span class='rusttest'>mod a {
    // X!(); // undefined
}
macro_rules! X { () =&gt; {}; }
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='comment'>// X!(); // undefined</span>
}
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>X</span> { () <span class='op'>=&gt;</span> {}; }
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined</span>
}
<span class='kw'>mod</span> <span class='ident'>c</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined</span>
}</pre>

<p>However, this dependency <em>does not</em> apply to macros themselves:</p>

<span class='rusttest'>mod a {
    // X!(); // undefined
}
macro_rules! X { () =&gt; { Y!(); }; }
mod b {
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod c {
    X!(); // defined, and so is Y!
}
fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='comment'>// X!(); // undefined</span>
}
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>X</span> { () <span class='op'>=&gt;</span> { <span class='macro'>Y</span><span class='macro'>!</span>(); }; }
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='comment'>// X!(); // defined, but Y! is undefined</span>
}
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>Y</span> { () <span class='op'>=&gt;</span> {}; }
<span class='kw'>mod</span> <span class='ident'>c</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined, and so is Y!</span>
}</pre>

<p>Macros can be exported from a module using the <code>#[macro_use]</code> attribute.</p>

<span class='rusttest'>mod a {
    // X!(); // undefined
}
#[macro_use]
mod b {
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    X!(); // defined
}
fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='comment'>// X!(); // undefined</span>
}
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>X</span> { () <span class='op'>=&gt;</span> {}; }
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined</span>
}
<span class='kw'>mod</span> <span class='ident'>c</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined</span>
}</pre>

<p>Note that this can interact in somewhat bizarre ways due to the fact that identifiers in a macro (including other macros) are only resolved upon expansion:</p>

<span class='rusttest'>mod a {
    // X!(); // undefined
}
#[macro_use]
mod b {
    macro_rules! X { () =&gt; { Y!(); }; }
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod c {
    X!(); // defined, and so is Y!
}
fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='comment'>// X!(); // undefined</span>
}
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>X</span> { () <span class='op'>=&gt;</span> { <span class='macro'>Y</span><span class='macro'>!</span>(); }; }
    <span class='comment'>// X!(); // defined, but Y! is undefined</span>
}
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>Y</span> { () <span class='op'>=&gt;</span> {}; }
<span class='kw'>mod</span> <span class='ident'>c</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined, and so is Y!</span>
}</pre>

<p>Another complication is that <code>#[macro_use]</code> applied to an <code>extern crate</code> <em>does not</em> behave this way: such declarations are effectively <em>hoisted</em> to the top of the module.  Thus, assuming <code>X!</code> is defined in an external crate called <code>mac</code>, the following holds:</p>

<span class='rusttest'>mod a {
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod b {
    X!(); // defined, and so is Y!
}
#[macro_use] extern crate macs;
mod c {
    X!(); // defined, and so is Y!
}
fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='comment'>// X!(); // defined, but Y! is undefined</span>
}
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>Y</span> { () <span class='op'>=&gt;</span> {}; }
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined, and so is Y!</span>
}
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span> <span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>macs</span>;
<span class='kw'>mod</span> <span class='ident'>c</span> {
    <span class='macro'>X</span><span class='macro'>!</span>(); <span class='comment'>// defined, and so is Y!</span>
}</pre>

<p>Finally, note that these scoping behaviours apply to <em>functions</em> as well, with the exception of <code>#[macro_use]</code> (which isn&#39;t applicable):</p>

<span class='rusttest'>macro_rules! X {
    () =&gt; { Y!() };
}

fn a() {
    macro_rules! Y { () =&gt; {&quot;Hi!&quot;} }
    assert_eq!(X!(), &quot;Hi!&quot;);
    {
        assert_eq!(X!(), &quot;Hi!&quot;);
        macro_rules! Y { () =&gt; {&quot;Bye!&quot;} }
        assert_eq!(X!(), &quot;Bye!&quot;);
    }
    assert_eq!(X!(), &quot;Hi!&quot;);
}

fn b() {
    macro_rules! Y { () =&gt; {&quot;One more&quot;} }
    assert_eq!(X!(), &quot;One more&quot;);
}

fn main() {
    a();
    b();
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>X</span> {
    () <span class='op'>=&gt;</span> { <span class='macro'>Y</span><span class='macro'>!</span>() };
}

<span class='kw'>fn</span> <span class='ident'>a</span>() {
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>Y</span> { () <span class='op'>=&gt;</span> {<span class='string'>&quot;Hi!&quot;</span>} }
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>X</span><span class='macro'>!</span>(), <span class='string'>&quot;Hi!&quot;</span>);
    {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>X</span><span class='macro'>!</span>(), <span class='string'>&quot;Hi!&quot;</span>);
        <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>Y</span> { () <span class='op'>=&gt;</span> {<span class='string'>&quot;Bye!&quot;</span>} }
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>X</span><span class='macro'>!</span>(), <span class='string'>&quot;Bye!&quot;</span>);
    }
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>X</span><span class='macro'>!</span>(), <span class='string'>&quot;Hi!&quot;</span>);
}

<span class='kw'>fn</span> <span class='ident'>b</span>() {
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>Y</span> { () <span class='op'>=&gt;</span> {<span class='string'>&quot;One more&quot;</span>} }
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>X</span><span class='macro'>!</span>(), <span class='string'>&quot;One more&quot;</span>);
}</pre>

<p>These scoping rules are why a common piece of advice is to place all macros which should be accessible &quot;crate wide&quot; at the very top of your root module, before any other modules.  This ensures they are available <em>consistently</em>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>
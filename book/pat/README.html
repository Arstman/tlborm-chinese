<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Patterns</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../mbe.html'><b>2.</b> Macro by Example</a>
</li>
<li><a class='active' href='../pat/README.html'><b>3.</b> Patterns</a>
</li>
<li><a  href='../blk/README.html'><b>4.</b> Building Blocks</a>
<ul class='section'>
<li><a  href='../blk/counting.html'><b>4.1.</b> Counting</a>
</li>
</ul>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Patterns</h1>
    <p>Parsing and expansion patterns.</p>

<h1 id="internal-rules" class='section-header'><a
                           href="#internal-rules">Internal rules</a></h1><span class='rusttest'>fn main() {
    #[macro_export]
    macro_rules! foo {
        (@as_expr $e:expr) =&gt; {$e};
    
        // ...
    
        ($($tts:tt)*) =&gt; {
            foo!(@as_expr $($tts)*)
        };
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='kw-2'>@</span><span class='ident'>as_expr</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>};

    <span class='comment'>// ...</span>

    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tts</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>foo</span><span class='macro'>!</span>(<span class='kw-2'>@</span><span class='ident'>as_expr</span> $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tts</span>)<span class='op'>*</span>)
    };
}</pre>

<p>Because macros do not interact with regular item privacy or lookup, any public macro <em>must</em> bring with it all other macros that it depends on.  This can lead to pollution of the global macro namespace, or even conflicts with macros from other crates.  It may also cause confusion to users who attempt to <em>selectively</em> import macros: they must transitively import <em>all</em> macros, including ones that may not be publicly documented.</p>

<p>A good solution is to conceal what would otherwise be other public macros <em>inside</em> the macro being exported.  The above example shows how the common <code>as_expr!</code> macro could be moved <em>into</em> the publicly exported macro that is using it.</p>

<p>The reason for using <code>@</code> is that, as of Rust 1.2, the <code>@</code> token is <em>not</em> used <em>anywhere</em> in the Rust grammar; as such, it cannot possibly conflict with anything.  Other symbols or unique prefixes may be used as desired, but use of <code>@</code> has started to become widespread, so using it may aid readers in understanding your code.</p>

<blockquote>
<p><strong>Note</strong>: the <code>@</code> token is a hold-over from when Rust used sigils to denote the various built-in pointer types.  <code>@</code> in particular was for garbage-collected pointers.</p>
</blockquote>

<p>Additionally, internal rules will often come <em>before</em> any &quot;bare&quot; rules, to avoid issues with <code>macro_rules!</code> incorrectly attempting to parse an internal invocation as something it cannot possibly be, such as an expression.</p>

<p>If exporting at least one internal macro is unavoidable (<em>e.g.</em> you have many macros that depend on a common set of utility rules), you can use this pattern to combine <em>all</em> internal macros into a single uber-macro.</p>
<span class='rusttest'>fn main() {
    macro_rules! crate_name_util {
        (@as_expr $e:expr) =&gt; {$e};
        (@as_item $i:item) =&gt; {$i};
        (@count_tts) =&gt; {0usize};
        // ...
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>crate_name_util</span> {
    (<span class='kw-2'>@</span><span class='ident'>as_expr</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>};
    (<span class='kw-2'>@</span><span class='ident'>as_item</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>i</span>:<span class='ident'>item</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>i</span>};
    (<span class='kw-2'>@</span><span class='ident'>count_tts</span>) <span class='op'>=&gt;</span> {<span class='number'>0usize</span>};
    <span class='comment'>// ...</span>
}</pre>

<h1 id="repetition-replacement" class='section-header'><a
                           href="#repetition-replacement">Repetition replacement</a></h1><span class='rusttest'>fn main() {
    macro_rules! replace_expr {
        ($_t:tt $sub:expr) =&gt; {$sub};
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>replace_expr</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_t</span>:<span class='ident'>tt</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sub</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>sub</span>};
}</pre>

<p>This pattern is where a matched repetition sequence is simply discarded, with the variable being used to instead drive some repeated pattern that is related to the input only in terms of length.</p>

<p>For example, consider constructing a default instance of a tuple with more than 12 elements (the limit as of Rust 1.2).</p>
<span class='rusttest'>fn main() {
    macro_rules! tuple_default {
        ($($tup_tys:ty),*) =&gt; {
            (
                $(
                    replace_expr!(
                        ($tup_ty)
                        Default::default()
                    ),
                )*
            )
        };
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>tuple_default</span> {
    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tup_tys</span>:<span class='ident'>ty</span>),<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        (
            $(
                <span class='macro'>replace_expr</span><span class='macro'>!</span>(
                    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tup_ty</span>)
                    <span class='ident'>Default</span>::<span class='ident'>default</span>()
                ),
            )<span class='op'>*</span>
        )
    };
}</pre>

<blockquote>
<p><strong>JFTE</strong>: we <em>could</em> have simply used <code>$tup_tys::default()</code>.</p>
</blockquote>

<p>Here, we are not actually <em>using</em> the matched types.  Instead, we throw them away and instead replace them with a single, repeated expression.  To put it another way, we don&#39;t care <em>what</em> the types are, only <em>how many</em> there are.</p>

<h1 id="trailing-separators" class='section-header'><a
                           href="#trailing-separators">Trailing separators</a></h1><span class='rusttest'>fn main() {
    macro_rules! match_exprs {
        ($($exprs:expr),* $(,)*) =&gt; {...};
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>match_exprs</span> {
    ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>exprs</span>:<span class='ident'>expr</span>),<span class='op'>*</span> $(,)<span class='op'>*</span>) <span class='op'>=&gt;</span> {...};
}</pre>

<p>There are various places in the Rust grammar where trailing commas are permitted.  The two common ways of matching (for example) a list of expressions (<code>$($exprs:expr),*</code> and <code>$($exprs:expr,)*</code>) can deal with <em>either</em> no trailing comma <em>or</em> a trailing comma, but <em>not both</em>.</p>

<p>Placing a <code>$(,)*</code> repetition <em>after</em> the main list, however, will capture any number (including zero or one) of trailing commas, or any other separator you may be using.</p>

<p>Note that this cannot be used in all contexts.  If the compiler rejects this, you will likely need to use multiple arms and/or incremental matching.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        prevNode.setAttribute('rel', 'prev');
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nextNode.setAttribute('rel', 'next');
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>